from xbmctorrent import plugin
from xbmctorrent.scrapers import scraper
from xbmctorrent.ga import tracked


BASE_URL = "http://eztv.it"
HEADERS = {
    "Referer": BASE_URL,
}


@scraper("EZTV - Series", "http://ezimg.it/s/1/1/eztv-logo-small.png")
@plugin.route("/eztv")
@tracked
def eztv_index():
    import string
    for letter in ["0-9"] + list(string.ascii_uppercase):
        yield {
            "label": letter,
            "path": plugin.url_for("eztv_shows_by_letter", letter=letter),
            "is_playable": False,
        }


@plugin.route("/eztv/shows/<letter>")
@tracked
def eztv_shows_by_letter(letter):
    import re
    import xbmc
    import xbmcgui
    from bs4 import BeautifulSoup
    from contextlib import nested, closing
    from itertools import izip, groupby
    from multiprocessing.pool import ThreadPool
    from xbmctorrent.scrapers import ungenerate
    from xbmctorrent.utils import terminating, url_get
    from xbmctorrent import tvdb

    plugin.set_content("tvshows")
    shows_cache = plugin.get_storage("eztv_shows") # 1 day cache
    if not len(shows_cache.keys()):
        response = url_get("http://eztv.it/showlist/", headers=HEADERS)
        soup = BeautifulSoup(response.text, "html5lib")
        nodes = soup.findAll("a", "thread_link")
        for node in nodes:
            show_id, show_named_id = node["href"].split("/")[2:4]
            show_name = node.text
            show_first_letter = show_name[0].lower()
            if re.match("\d+", show_first_letter):
                show_first_letter = "0-9"
            shows_cache.setdefault(show_first_letter, {}).update({
                show_id: {
                    "id": show_id,
                    "named_id": show_named_id,
                    "name": node.text,
                }
            })

    shows_list = sorted(shows_cache[letter.lower()].values(), key=lambda x: x["name"].lower())

    @plugin.cached()
    @ungenerate
    def _eztv_shows_by_letter(letter):
        with closing(xbmcgui.DialogProgress()) as dialog:
            dialog.create(plugin.name)
            dialog.update(percent=0, line1="Fetching serie information...", line2="", line3="")

            state = {"done": 0}
            def on_serie(data):
                state["done"] += 1
                dialog.update(
                    percent=int(state["done"] * 100.0 / len(shows_list)),
                    line2=data and data["seriesname"] or "",
                )

            with terminating(ThreadPool(5)) as pool_tvdb:
                tvdb_list = [pool_tvdb.apply_async(tvdb.search, [show["name"], True], callback=on_serie) for show in shows_list]
                while not all(job.ready() for job in tvdb_list):
                    if dialog.iscanceled():
                        dialog.close()
                        return
                    xbmc.sleep(50)

        tvdb_list = [job.get() for job in tvdb_list]
        for i, (eztv_show, tvdb_show) in enumerate(izip(shows_list, tvdb_list)):
            if tvdb_show:
                item = tvdb.get_list_item(tvdb_show)
                item.update({
                    "path": plugin.url_for("eztv_get_show_seasons", show_id=eztv_show["id"], tvdb_id=tvdb_show["id"])
                })
                yield item
            else:
                yield {
                    "label": eztv_show["name"],
                    "path": plugin.url_for("eztv_get_show_seasons", show_id=eztv_show["id"])
                }
    return _eztv_shows_by_letter(letter)


def get_episode_data_from_name(name):
    import re
    res = re.search("S(\d+)E(\d+)", name)
    if res:
        return map(int, res.groups())
    res = re.search("(\d+)x(\d+)", name)
    if res:
        return map(int, res.groups())
    return -1, -1


@plugin.route("/eztv/shows/<show_id>/seasons")
@tracked
def eztv_get_show_seasons(show_id):
    import random
    from bs4 import BeautifulSoup
    from itertools import groupby
    from multiprocessing.pool import ThreadPool
    from xbmctorrent.utils import first, terminating, url_get
    from xbmctorrent import tvdb

    # plugin.set_content("seasons")

    tvdb_id = first(plugin.request.args.get("tvdb_id"))
    with terminating(ThreadPool(2)) as pool:
        def _eztv_get_show():
            plugin.log.info("Getting show")
            response = url_get("http://eztv.it/shows/%s/" % show_id, headers=HEADERS)
            plugin.log.info("Got show")
            return BeautifulSoup(response, "html5lib")
        soup = pool.apply_async(_eztv_get_show)
        if tvdb_id:
            tvdb_show = pool.apply_async(tvdb.get_all_meta, [plugin.request.args["tvdb_id"][0]])

        soup = soup.get()
        fanarts = []
        if tvdb_id:
            tvdb_show = tvdb_show.get()
            fanarts = list([banner for banner in tvdb_show["banners"] if banner["bannertype"] == "fanart"])
            random.shuffle(fanarts)

        for node in soup.findAll("a", "epinfo"):
            if get_episode_data_from_name(node.text)[0] < 0:
                plugin.redirect(plugin.url_for("eztv_get_episodes_for_season", show_id=show_id, season=-1, tvdb_id=tvdb_id))
                return

        # This is needed because we need to be able to redirect if no seasons are found.
        items = []
        for i, (season, episodes) in enumerate(groupby(soup.findAll("a", "epinfo"), lambda node: get_episode_data_from_name(node.text)[0])):
            if tvdb_id:
                item = tvdb.get_season_list_item(tvdb_show, season)
            else:
                item = {
                    "label": "Season %d" % season
                }
            item.update({
                "path": plugin.url_for("eztv_get_episodes_for_season", show_id=show_id, season=season, tvdb_id=tvdb_id),
            })
            # if fanarts:
            item.setdefault("properties", {}).update({
                "fanart_image": fanarts[i % len(fanarts)]["bannerpath"],
            })
            items.append(item)
        return items


@plugin.route("/eztv/shows/<show_id>/<season>/episodes")
@tracked
def eztv_get_episodes_for_season(show_id, season):
    import copy
    import random
    from bs4 import BeautifulSoup
    from itertools import izip
    from multiprocessing.pool import ThreadPool
    from xbmctorrent.utils import first, terminating, url_get
    from xbmctorrent import tvdb

    plugin.set_content("episodes")
    season = int(season)
    tvdb_id = first(plugin.request.args.get("tvdb_id"))
    with terminating(ThreadPool(2)) as pool:
        def _eztv_get_show():
            return BeautifulSoup(url_get("http://eztv.it/shows/%s/" % show_id), "html5lib")
        soup = pool.apply_async(_eztv_get_show)
        if tvdb_id:
            tvdb_show = pool.apply_async(tvdb.get_all_meta, [plugin.request.args["tvdb_id"][0]])

        soup = soup.get()
        items = []
        fanarts = []
        if tvdb_id:
            tvdb_show = tvdb_show.get()
            fanarts = list([banner for banner in tvdb_show["banners"] if banner["bannertype"] == "fanart"])
            random.shuffle(fanarts)
            items = list(tvdb.build_episode_list_items(tvdb_show, int(season)))
        text_nodes = soup.findAll("a", "epinfo")
        href_nodes = soup.findAll("a", "magnet")
        season_nodes = izip(text_nodes, href_nodes)
        if season >= 0:
            season_nodes = filter(lambda x: ("S%02d" % season) in x[0].text, season_nodes)

        for i, (node_text, node_magnet) in enumerate(season_nodes):
            season, episode = get_episode_data_from_name(node_text.text)
            if tvdb_id and episode >= 0:
                item = copy.deepcopy(items[int(episode) - 1])
                for pattern, suffix in (("720p", "(HD)"), ("1080p", "(FullHD)"), ("repack", "(REPACK)"), ("proper", "(PROPER)")):
                    if pattern in node_text.text.lower():
                        item["label"] = "%s %s" % (item["label"], suffix)
            else:
                item = {
                    "label": node_text.text,
                }
            item.setdefault("info", {}).update({
                "tvshowtitle": node_text.text,
                "title": item["label"],
            })
            stream_info = {}
            if "x264" in node_text.text:
                stream_info["codec"] = item["info"]["video_codec"] = "h264"
            if "xvid" in node_text.text.lower():
                stream_info["codec"] = item["info"]["video_codec"] = "xvid"
            if "720p" in node_text.text:
                stream_info["width"] = 1280
                stream_info["height"] = 720
            if "1080p" in node_text.text:
                stream_info["width"] = 1920
                stream_info["height"] = 1080
            item.update({
                "path": plugin.url_for("play", magnet=node_magnet["href"]),
                "stream_info": {"video": stream_info},
                "is_playable": True,
            })
            if fanarts:
                item.setdefault("properties", {}).update({
                    "fanart_image": fanarts[i % len(fanarts)]["bannerpath"],
                })
            yield item
